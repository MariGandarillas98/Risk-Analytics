---
title: "Risk Analytics"
output: html_document
date: "2024-10-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
install.packages(c("tseries", "urca", "forecast", "nortest", "MASS"))
library(tseries)
library(urca)
library(forecast)
library(readxl)
library(dplyr)
library(ggplot2)
library(nortest)
library(MASS)
library(stats)    
library(fGarch)
```

## Practical 1

## Part 1: Financial returns and normality

1.  **Read in the Bitcoin data from le Crypto data.csv. Then, assess the stationarity of the (raw) Bitcoin prices.**

    ```{r echo=FALSE}
    #Uploading the data set
    crypto<-read.csv("Crypto_data.csv")

    bitcoin_ts <- ts(crypto$Bitcoin, 
                     start = c(1),       
                     frequency = 1440)



    plot(bitcoin_ts, type = "l", main = "Bitcoin Prices", xlab = "Time", col = "red")

    # Plotting the Q-Q plot

    qqnorm(bitcoin_ts, main = "Normal Q-Q Plot")
    qqline(bitcoin_ts, col = "red")



    ```

    The plots show that the distribution of the data base is not normal and a clear trend over the years. However, it is needed to review it in detail. Let's check it out in more detail

    ```{r}

    # Plotting the cumulative periodogram
    cpgram(bitcoin_ts, main = "Cumulative Periodogram")


    ```

    The cumulative periodogram shows clearly that the data base is not stationary as the observations are outside the confidence interval of white noise stationarity.

    ```{r}
    # Plotting the ACF and PACF
    par(mfrow = c(2, 2))
    acf(bitcoin_ts, main = "ACF Plot")
    pacf(bitcoin_ts, main = "PACF Plot")
    par(mfrow = c(1, 1))

    ```

    The no stationarty is confirmed by the PACF and ACF plots as they show clear patterns in both of them.

    ```{r}
    # KPSS Test
    kpss_test <- ur.kpss(bitcoin_ts)
    summary(kpss_test)
    ```

    Finally, the KPSS test suggests that we can rejec the Ho of stationarity concluding that the prices of the Bitcoin are not stationary.

2.  **Create a function to transform the Bitcoin prices into their negative log returns counterparts. Plot the latter series and assess their stationarity. To compare the series, also plot the negative log returns on a common scale.**

    ```{r}
    bitcoin_log_returns <- diff(log(bitcoin_ts))
    plot(bitcoin_log_returns, type = "l", main = "Negative Log Returns of Bitcoin Prices", 
         ylab = "Negative Log Returns", xlab = "Time", col = "blue")
    ```

    This graph suggest us that the negative logaritmic returns are more similar to a stationary data base than the original one.

    ```{r}
    plot(bitcoin_ts, type = "l", col = "red", lwd = 2, 
         main = "Bitcoin Prices and Negative Log Returns", 
         ylab = "Bitcoin Prices", xlab = "Time")

    # Add the second series (negative log returns) on a secondary axis
    par(new = TRUE)
    plot(bitcoin_log_returns, type = "l", col = "blue", lwd = 2, axes = FALSE, 
         xlab = "", ylab = "")
    axis(side = 4) # Add axis on the right side
    mtext("Negative Log Returns", side = 4, line = 3) # Label for the secondary axis

    # Add a legend
    legend("topright", legend = c("Bitcoin Prices", "Negative Log Returns"), 
           col = c("red", "blue"), lty = 1, lwd = 2)
    ```

    When we plot it together, it is easy to see how the logaritmic data set is closer to what we can call stationarity.

3.  **Are the negative log returns normally distributed? Draw histograms, check QQ-plots and use an Anderson-Darling testing procedure to answer this question.**

    ```{r}
    # Plot Histogram of negative log returns
    hist(bitcoin_log_returns, breaks = 50, main = "Histogram of Negative Log Returns",
         xlab = "Negative Log Returns", col = "lightblue", border = "black", probability = TRUE)


    # QQ-Plot to check for normality
    qqnorm(bitcoin_log_returns, main = "QQ-Plot of Negative Log Returns")
    qqline(bitcoin_log_returns, col = "blue", lwd = 2)


    ```

    The histogram suggests a normal distributions while the QQplot shows some desviations at the tails that make us believe that there could be some problems with the distribution.

    ```{r}
    print(ad.test(bitcoin_log_returns))
    ```

    This test helps us to confirm our observation about the normal distribution. As the p value is lover than 5% we can reject the normality and confirm that the negative log returns are not normally distributed.

4.  **Fit a t-distribution to the negative log returns using fitdistr(). Using a QQ-plot, decide whether the t is better than with a Normal distribution, based on your answer in (3).**

    ```{r}
    bitcoin_log_returns_nots <- crypto$Bitcoin[!is.nan(crypto$Bitcoin) & is.finite(crypto$Bitcoin)]


    fit_t <- fitdistr(bitcoin_log_returns_nots, "t")

    fit_t_dis<- (crypto$Bitcoin-fit_t$estimate[1])/fit_t$sd[1]

    fit_t_dis_ts<-ts(fit_t_dis, 
                     start = c(1),       
                     frequency = 1440)

    qqnorm(fit_t_dis_ts, main = "QQ-Plot of Negative Log t Returns")
    qqline(fit_t_dis_ts, col = "blue", lwd = 2)

    ```

    Comparing this chart with the normal distribution plot, we can say that the normal distribution was better than the t distribution as it is closer to the blue line.

5.  **Compare the tails of the densities of the t-distribution and the normal distribution. Can we expect more extreme, unexpected events in t-distribution or in normal distribution? What can you conclude about the extreme events of our bitcoin data?**

    Both tails deviate significantly from the blue line, indicating that Bitcoin is prone to extreme events. However, the t-distribution exhibits greater tail density compared to the normal distribution, suggesting that the t-distribution allows for a higher likelihood of unexpected, extreme events.

## Part 2: Financial time series, heteroscedasticity and the random walk hypothesis

```{r}
# Plot ACF of the raw Bitcoin series
acf(crypto$Bitcoin, main = "ACF of Raw Bitcoin Prices", lag.max = 50)

# Calculate the negative log returns
log_returns <- diff(log(crypto$Bitcoin))  # Log returns
neg_log_returns <- -log_returns            # Negative log returns

# Plot ACF of the negative log returns
acf(neg_log_returns, main = "ACF of Negative Log Returns", lag.max = 50)
```
The ACF of the raw Bitcoin price series shows high autocorrelation at multiple lags, indicating a strong positive, declining trend and non-stationarity. This suggests that the raw series exhibits significant dependencies and is harder to model. In contrast, the ACF of the negative log returns is mostly within the confidence intervals, suggesting little to no autocorrelation and a stationary series. Since the negative log returns exhibit less persistence and randomness, they are easier to model and more suitable for time series analysis compared to the raw Bitcoin prices.

```{r}
ljung_box_raw <- Box.test(crypto$Bitcoin, type = "Ljung-Box", lag = 20)
print(ljung_box_raw)


ljung_box_neg_log <- Box.test(neg_log_returns, type = "Ljung-Box", lag = 20)
print(ljung_box_neg_log)
```

Since the p-value is much smaller than 0.05, we reject the null hypothesis, indicating that there is significant autocorrelation in the raw Bitcoin price series. This confirms that the raw Bitcoin series is non-stationary and exhibits strong trends and patterns over time, as suggested by the ACF plot. Since the p-value is just below 0.05, we also reject the null hypothesis, suggesting weak serial dependence in the negative log returns, though the level of dependence is much weaker compared to the raw Bitcoin series. While the negative log returns series is closer to stationarity (as indicated by the ACF plot), there is still a slight level of autocorrelation present.


```{r}
# Fit a manually proposed ARIMA model 
manual_ARIMA_model <- arima(neg_log_returns, order = c(1, 0, 1))

# Print the manually selected model
print(manual_ARIMA_model)


# Use auto.arima() to select the best ARIMA model
auto_ARIMA_model <- auto.arima(neg_log_returns)

# Print the selected ARIMA model
print(auto_ARIMA_model)

# Assess residuals of the manually proposed ARIMA model
checkresiduals(manual_ARIMA_model)

# Assess residuals of the auto.arima() model
checkresiduals(auto_ARIMA_model)
```

The auto ARIMA(2, 0, 2) model is likely preferred because it has a lower AIC value, suggesting a better balance between fit and complexity. The first model provides a simpler representation but may not capture the underlying dynamics as effectively as the second model. The stronger coefficients in the second model suggest it can explain the data with greater accuracy. We reject the null hypothesis of no autocorrelation in the residuals for manual ARIMA(1, 0, 1) model. This indicates that there is significant autocorrelation. The model may not adequately capture the time series dynamics, suggesting that it might be beneficial to consider a more complex model. For auto ARIMA(2, 0, 2) we accept the null hypothesis of no autocorrelation in the residuals. This indicates that the residuals from the ARIMA(2, 0, 2) model behave like white noise, suggesting that this model adequately captures the time series dynamics.


```{r}
# Fit GARCH(1, 1) with normal distribution
garch_normal <- garchFit(formula = ~ garch(1, 1), data = neg_log_returns, 
                          cond.dist = "norm")

# Print the summary of the GARCH model with normal distribution
summary(garch_normal)

# Fit GARCH(1, 1) with standardized t-distribution
garch_t <- garchFit(formula = ~ garch(1, 1), data = neg_log_returns, 
                     cond.dist = "std")

# Print the summary of the GARCH model with t-distribution
summary(garch_t)

# Assess residuals for GARCH model with normal distribution
residuals_normal <- residuals(garch_normal)

# Evaluate residuals for GARCH model with normal distribution
par(mfrow = c(2, 2))  # Set up plot layout for residual diagnostics

# Plot residuals for the GARCH model with normal distribution
plot(residuals_normal, main = "Residuals of GARCH Model (Normal)", 
     ylab = "Residuals", xlab = "Time")

# ACF of residuals for the GARCH model with normal distribution
acf(residuals_normal, main = "ACF of Residuals (Normal)")

# Assess residuals for GARCH model with t-distribution
residuals_t <- residuals(garch_t)
# Plot residuals for the GARCH model with t-distribution
plot(residuals_t, main = "Residuals of GARCH Model (t-Distribution)", 
     ylab = "Residuals", xlab = "Time")

# ACF of residuals for the GARCH model with t-distribution
acf(residuals_t, main = "ACF of Residuals (t-Distribution)")
```

The GARCH(1, 1) model with standardized t-distribution appears to be the better fitting model for the negative log returns, given the log-likelihood, AIC, and the inclusion of a shape parameter. Both models exhibit significant coefficients for ( \omega ), ( \alpha\_1 ), and ( \beta\_1 ). Despite both models showing non-normality in residuals, they both adequately model the autocorrelation structure of the returns.


```{r}
# Obtain the residuals from the ARIMA model
arima_residuals <- residuals(auto_ARIMA_model)

# Fit a GARCH(1, 1) model on the ARIMA residuals
garch_arima <- garchFit(formula = ~ garch(1, 1), data = arima_residuals, cond.dist = "norm")

# Print the summary of the GARCH model fitted on ARIMA residuals
summary(garch_arima)

# Assess the residuals of the GARCH model
# Check for autocorrelation in the residuals
garch_residuals <- residuals(garch_arima)

# Plot ACF of standardized residuals
acf(garch_residuals)

# Plot PACF of standardized residuals
pacf(garch_residuals)
```

The GARCH(1, 1) model on the residuals of the ARIMA(2, 0, 2) model indicates significant volatility persistence, as evidenced by the significant α1 and β1 coefficients. The Ljung-Box test results suggest that the residuals do not exhibit serial correlation, indicating a good fit for the model. ACF and PACF of the residuals indicate that GARCH model has adequately captured the temporal dependencies in the data suggesting that the model is a good fit for the data.

To compare the three models (ARIMA, GARCH, and ARIMA-GARCH) we consider various criteria such as model fit, statistical significance, and the homoscedasticity assumption. The ARIMA-GARCH model is the most suitable because it effectively captures both the mean and the variance of the negative log returns. It addresses the limitations of the ARIMA model alone, which may not handle volatility adequately, while also confirming the improvements in fit over the standalone GARCH model. The ARIMA model is where the homoscedasticity assumption is most likely violated, as it does not account for the changing variance inherent in financial time series data. In contrast, both the GARCH and ARIMA-GARCH models explicitly model volatility, thereby addressing this assumption.

## Part 3:
